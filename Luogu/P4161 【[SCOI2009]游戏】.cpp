//知识点: 问题转化 , 背包DP 
/*
题解地址: https://www.luogu.org/blog/koishikoishi/solution-p41611

原题面:
对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。
最开始windy把数字按顺序1，2，3，……，N写一排在纸上。
然后再在这一排下面写上它们对应的数字。
然后又在新的一排下面写上它们对应的数字。
如此反复，直到序列再次变为1，2，3，……，N。

对于所有可能的对应关系，有多少种可能的排数。
 
 

原题面非常神仙不可做, 
从图的角度,对题面进行转化:
	有n个点和 n条有向边
	每个点都只有一条入边和一条出边, 允许自环,
	每个点按照出边的方向进行转移. 
	最后回到原状态. 
	
	边可以任意连接,
	求回到原状态 不同的步数 的数量.

再次分析:
	即在图中通过构建 环
	使每个点都位于一个环中
	最后回到原状态的步数
	显然,即 : lcm (i点所在环的环长) (i∈[1,n]) ; 

现在 原题面要求得的 "排数" , 
转化后要求的不同的步数的数量, 
即 不同的 环长的lcm 数

显然 , 所有环长之和==n  (包括 环长为1 的自环) 
现在问题转化成为了:
	构造 若干 和==n 的数
	使其不同的lcm数尽可能地多 

考虑怎样才能使 lcm数尽可能多:
	如果 每次构造时,
	都使这些数全都 互质
	那么他们的 lcm每次都是不同的.

怎样使这些数全部互质 ?
即: 将他们构造成 p^k 的形式 
	(p为质数,k∈[0,INF) && p^k<=n)

由于要使构造的数 和 == n
则可以取的质数 ∈ [2,n],
并且 (k∈[0,INF) && p^k<=n) 

于是问题继续转化: 
	给定的一些质数 ,
	每个质数可选择其任意次幂(包括0次幂) , 
	并选择任意多个 
	求其总和为 n 的方案数

对于可以无限取的 1,
考虑再次进行转化
任何一种 <n的背包容量
在添加无限个1后都会变成n

所以考虑 忽略掉所有的1
将 求总和为 n 的方案数
变为 求总和为 k (k<n) 的 方案数 





最后变成了一个完全背包问题
也就是说只要会背包
就可以作出这么Naive的题(大雾 
*/ 
#include<cstdio>
#include<ctype.h>
const int MARX = 1010;
//=============================================================
int n,num , prime[MARX];
bool vis[MARX];
long long ans,f[MARX]={1}; 
//=============================================================
inline int read() 
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
void get_prime()//埃氏筛筛出<=n的素数
{
    for(int i=2;i<=n;i++)
    {
      if(!vis[i]) prime[++num]=i;
      for(int j=1;i*j<=n;j++) vis[i*j]=1;
    } 
}
void dp()//完全背包 
{
    for(int i=1;i<=num;i++)//将每个质数拿出,作为物品 
      for(int k=n;k>=prime[i];k--)//枚举背包容量 
        for(int mul=prime[i];mul<=k;mul*=prime[i])//枚举 
          f[k]+=f[k-mul];
}
//=============================================================
signed main()
{
    n=read();
    get_prime();
    dp();
    for(int i=1;i<=n;i++) ans+=f[i];//获得各容量的方案数 
    printf("%lld",ans+1);//答案 = 总方案数 + 容量为0的方案 
}
