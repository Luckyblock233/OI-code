//算法：DP
//一道题意不清的破题=_=

//由题意知,
//对于一层,可以跳,不消耗时间,但是不可连续跳跃;
//也可以爬,消耗时间=该层高度

//所以设置一个二维数组,
//记录到某一层,跳上去的最小时间, 
//和到某一层,爬上去的最小时间.

//爬到某一层,可以由 跳到上一层 或者 爬到上一层 转移
//跳到某一层,只能由 爬到上一层 或者 爬到上两层 转移 

//然后可以退出状态转移方程:
//1爬，2跳 
//f[i][1]=min(f[i-1][1],f[i-1][2])+a[i];
//f[i][2]=min(f[i-1][1],f[i-2][1]);
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int a[1000010];
int f[1000010][3];//1爬，2跳 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	  scanf("%d",&a[i]);
	f[1][1]=a[1],f[1][2]=0;
	for(int i=2;i<=n;i++)
	  {
	  	f[i][1]=min(f[i-1][1],f[i-1][2])+a[i];
	  	f[i][2]=min(f[i-1][1],f[i-2][1]);
	  }
	printf("%d",min(f[n][1],f[n][2])); 
} 
