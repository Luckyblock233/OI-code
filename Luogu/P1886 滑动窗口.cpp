/*
此题为单调队列模板题，底下有无注释版 


单调队列有两个性质
队列中的元素其对应在原来的列表中的顺序必须是单调递增的。

队列中元素的大小必须是单调递(增/减/甚至是自定义也可以)

单调队列与普通队列不一样的地方
就在于单调队列既可以从队首出队，
也可以从队尾出队。
那么我们应该怎样实现单调队列呢?
就拿样例来谈谈，设以最小的为标准。
8 3
1 3 -1 -3 5 3 6 7

下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。

由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。

现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}

下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从队尾出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}

出现-3，同上面分析，-1>-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。

出现5，因为5>-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}

出现3。3先与队尾的5比较，3<5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}

出现6。6与3比较，因为3<6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从队首出队。此时，q={3,6},p={6,7}

出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。

那么，我们对单调队列的基本操作已经分析完毕。
因为单调队列中元素大小单调递*(增/减/自定义比较)，
因此，队首元素必定是最值。
按题意输出即可。
*/
#include<cmath>
#include<cstdio>
using namespace std;
int n,k;
int a[1000010];
int q[1000010],head[1000010];
void minn()//小值 
{
	int h=1,t=0;
/*	
	h为头,t为尾 
	为啥要这样赋初值呢?
	因为head要严格对应首元素，
	tail要严格对应尾元素，
	所以当tail>=head时，
	说明有元素。
	而一开始队列为空，
	说一要这样赋值。
	其实这跟普通队列一样。 
*/ 
	for(int i=1;i<=n;i++)
	  {//a[i]表示当前要处理的值
	  	while(q[t]>=a[i] && t>=h)
	  	  t--;
/*
	    只要队列里有元素，
		并且尾元素比待处理值大，
		即表示尾元素已经不可能出场，
		所以出队。
		直到尾元素小于待处理值，
		满足"单调"。
*/
	  	q[++t]=a[i];//待处理值入队。
	  	head[t]=i;//同时存下其编号
	  	if(head[h]<=i-k) h++;//如果队首元素已经"过时"，出队。
	  	if(i>=k) 
		  printf("%d ",q[h]);
		//输出最值，即队首元素。i>=k表示未到队尾，应该输出， 
	  }
	printf("\n");
}
void maxx()//大值 
{
	int h=1,t=0;
	for(int i=1;i<=n;i++)
	  {
	  	while(q[t]<=a[i] && t>=h)
	  	  t--;
	  	q[++t]=a[i];
	  	head[t]=i;
	  	if(head[h]<=i-k) h++;
	  	if(i>=k) 
		  printf("%d ",q[h]);
	  }
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	  scanf("%d",&a[i]);
	minn();
	maxx();
	return 0;
}
/*
//无注释版: 
#include<cmath>
#include<cstdio>
using namespace std;
int n,k;
int a[1000010];
int q[1000010],head[1000010];
void minn()
{
    int h=1,t=0;
    for(int i=1;i<=n;i++)
      {
      	while(q[t]>=a[i] && t>=h)
      	  t--;
      	q[++t]=a[i];
      	head[t]=i;
      	if(head[h]<=i-k) 
		  h++;
      	if(i>=k) 
          printf("%d ",q[h]);
      }
    printf("\n");
}
void maxx()
{
    int h=1,t=0;
    for(int i=1;i<=n;i++)
      {
      	while(q[t]<=a[i] && t>=h)
      	  t--;
      	q[++t]=a[i];
      	head[t]=i;
      	if(head[h]<=i-k) 
		  h++;
      	if(i>=k) 
		  printf("%d ",q[h]);
      }
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    minn();
    maxx();
    return 0;
}
*/ 
