//知识点:单调栈
/*
此题与 P1901 类似(但是更难 XD

维护一个 单调递减 的单调栈

对于一个新加入的人:
1.如果栈中有人,那么相邻的人多了一对,ans++ .
2.然后将栈从顶往下扫:
  ①如果 新加入的人<栈顶的人高度=<栈顶第二个人 , 
    说明能相互看到的人多了一对,ans++
    并将栈顶人弹出栈(他会被挡住 
    
  ②如果 新加入的人 <=栈顶的人的高度 , 
    1.如果新加入的人==栈顶人的高度, 
      说明新加入的人即将被挡住(他将遇到比他高的人 
	  新加入的人 还能看到的人数 = 栈顶和他一样高的人数+1
	  ans+=  栈顶和他一样高的人数+1 / 栈中人数(防止越界 
	2.如果新加入的人<栈顶人的高度
	  他将不能再看到其他人 
	然后结束循环扫描
	
3.
如果 新人高度==栈顶人高度,
连续的此高度人数++; 
并将新人加入栈,
*/ 
#include<cstdio>
using namespace std;
const int MARX = 5e6+10;
int n,h[MARX],pre[MARX];
long long sum;
int s[MARX],r=0;
int main()
{
	scanf("%d%d",&n,&h[1]);
	s[++r]=1;
	for(int i=2;i<=n;i++)
	  {
	  	scanf("%d",&h[i]);
	  	if(r>=1) sum++;//如果栈中有人,那么相邻的人多了一对,ans++ . 
		while(r>=1)
	  	  {
			if(h[s[r]]>=h[i])
			  {
			  	if(h[s[r]]==h[i])//.如果新加入的人==栈顶人的高度,  
				  sum+=(pre[s[r]]>=r-1?r-1:pre[s[r]]+1);
				break;//结束循环扫描
			  }
			if(h[s[r-1]]>=h[s[r--]]) sum++;//如果 新加入的人<栈顶的人高度=<栈顶第二个人 ,  
	      }
	    if(h[s[r]]==h[i]) pre[i]=pre[s[r]]+1;// 连续的此高度人数++; 
		s[++r]=i;//入栈 
	  }
	printf("%lld",sum);
}
