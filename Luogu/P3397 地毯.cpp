//知识点: 二维差分 
/*
By:Luckyblock
给定操作 矩阵 [(x1,y1),(x2,y2)]区间加数 
1.暴力修改
  复杂度O(n^2) 
2.进行 n次一维差分
  即, 对每一行 都维护一个差分数组
  每次修改时 , 修改[x1,x2]行的 差分数组
  复杂度O(n)
3.对2中修改后的 差分数组进行分析:
  0 0 0 0 0 	 0 0 0 0 0
  0 0 0 0 0		 0 1 0 0-1 
  0 0 0 0 0  --> 0 1 0 0-1  
  0 0 0 0 0 	 0 1 0 0-1 
  0 0 0 0 0 	 0 0 0 0 0
  可以发现 , 对每一行的 差分数组进行维护
  相当于 将 两列上的 数 同加/减 一个数
  
  所以 可以直接 再对每一列维护一个差分数组
  则修改后变成了这样: 
  0 0 0 0 0 	 0 0 0 0 0 		0 0 0 0 0
  0 0 0 0 0		 0 1 0 0-1 		0 1 0 0-1 
  0 0 0 0 0  --> 0 1 0 0-1  --> 0 0 0 0 0
  0 0 0 0 0 	 0 1 0 0-1 		0-1 0 0 1 
  0 0 0 0 0 	 0 0 0 0 0		0 0 0 0 0
  修改复杂度O(1) 
  上述过程 , 即二维差分 
  
4.根据上述推理过程 , 还可对差分进行更高维度的推广
  如果 要对 ?维规则区间 进 行修改 
  可以发现 , 多次差分 可以 实现修改复杂度的 (O(n^?) --> O(1)) 
*/
#include<cstdio>
#include<ctype.h>
const int MARX = 1010;
//=============================================================
int n,m, diff[MARX][MARX],sum[MARX][MARX];//差分数组,前缀和数组 
//=============================================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
//=============================================================
signed main()
{
	n=read(),m=read();
	for(int i=1; i<=m; i++)
	{
	  int x1=read(),y1=read(),x2=read(),y2=read();
	  diff[x1][y1]++,diff[x2+1][y2+1]++;//O(1)修改 矩阵 
	  diff[x2+1][y1]--,diff[x1][y2+1]--;
	}
	for(int i=1; i<=n; putchar('\n'),i++)
	  for(int j=1; j<=n; j++)//查询 
	  {
	  	//对 差分数组 做 前缀和 还原 原数组 
		sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + diff[i][j];
	    printf("%d ",sum[i][j]);
	  }
}
